from __future__ import annotations

from typing import Any, Union

from asyncio_redis.encoders import BaseEncoder
from asyncio_redis.protocol import Transaction
from asyncio_redis.replies import (
    BlockingPopReply,
    BlockingZPopReply,
    DictReply,
    PubSubReply,
    SetReply,
    StatusReply,
)

class Subscription:
    async def subscribe(self, channels: list[_Key]) -> None: ...
    async def unsubscribe(self, channels: list[_Key]) -> None: ...
    async def psubscribe(self, channels: list[_Key]) -> None: ...
    async def punsubscribe(self, channels: list[_Key]) -> None: ...
    async def next_published(self) -> PubSubReply: ...

_Key = Union[bytes, str]

class Connection:
    @classmethod
    async def create(
        cls,
        host: str = ...,
        port: int = ...,
        *,
        password: str | bytes | None = ...,
        db: int = ...,
        encoder: BaseEncoder | None = ...,
        auto_reconnect: bool = ...,
        loop: Any | None = ...,
        protocol_class: Any = ...,
        ssl: bool | None = ...,
    ) -> Connection: ...
    def close(self) -> None: ...
    async def hgetall(self, key: _Key) -> DictReply: ...
    async def hset(self, key: _Key, field: _Key, value: _Key) -> int: ...
    async def delete(self, keys: list[_Key]) -> int: ...
    async def blpop(self, keys: list[_Key], timeout: int = ...) -> BlockingPopReply: ...
    async def bzpopmin(
        self, keys: list[_Key], timeout: int = ...
    ) -> BlockingZPopReply: ...
    async def get(self, key: _Key) -> str | None: ...
    async def rpush(self, key: _Key, values: list[_Key]) -> int: ...
    async def ltrim(
        self, key: _Key, start: int = ..., stop: int = ...
    ) -> StatusReply: ...
    async def sadd(self, key: _Key, values: list[_Key]) -> int: ...
    async def expire(self, key: _Key, seconds: int) -> int: ...
    async def zrem(self, key: _Key, members: list[_Key]) -> int: ...
    async def zadd(
        self,
        key: _Key,
        values: dict[str, Any],
        only_if_not_exists: bool = ...,
        only_if_exists: bool = ...,
        return_num_changed: bool = ...,
    ) -> int: ...
    async def publish(self, channel: _Key, message: _Key) -> int: ...
    async def set(
        self,
        key: _Key,
        value: _Key,
        expire: int | None = ...,
        pexpire: int | None = ...,
        only_if_not_exists: bool = ...,
        only_if_exists: bool = ...,
    ) -> StatusReply | None: ...
    async def smembers(self, key: _Key) -> SetReply: ...
    async def start_subscribe(self) -> Subscription: ...
    async def multi(self) -> Transaction: ...

__all__ = ["Connection"]
